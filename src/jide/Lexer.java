/* The following code was generated by JFlex 1.4.3 on 26/05/23, 13:20 */
package jide;

import java.io.*;
import static jide.Tokens.*;

/**
 * This class is a scanner generated by
 * <a href="http://www.jflex.de/">JFlex</a> 1.4.3 on 26/05/23, 13:20 from the
 * specification file
 * <tt>C:/Users/juanp/OneDrive/Documentos/Workspace/JIDE/src/jide/Lexer.flex</tt>
 */
class Lexer {

    /**
     * This character denotes the end of file
     */
    public static final int YYEOF = -1;

    /**
     * initial size of the lookahead buffer
     */
    private static final int ZZ_BUFFERSIZE = 16384;

    /**
     * lexical states
     */
    public static final int YYINITIAL = 0;

    /**
     * ZZ_LEXSTATE[l] is the state in the DFA for the lexical state l
     * ZZ_LEXSTATE[l+1] is the state in the DFA for the lexical state l at the
     * beginning of a line l is of the form l = 2*k, k a non negative integer
     */
    private static final int ZZ_LEXSTATE[] = {
        0, 0
    };

    /**
     * Translates characters to character classes
     */
    private static final String ZZ_CMAP_PACKED
            = "\11\0\1\15\1\11\2\0\1\16\22\0\1\14\1\57\1\7\2\0"
            + "\1\54\1\61\1\12\1\45\1\46\1\20\1\6\1\43\1\2\1\4"
            + "\1\17\12\3\1\44\1\42\1\55\1\53\1\56\2\0\32\1\1\47"
            + "\1\10\1\50\1\0\1\1\1\0\1\26\1\13\1\30\1\31\1\5"
            + "\1\35\1\25\1\1\1\32\2\1\1\37\1\27\1\33\1\24\1\22"
            + "\1\1\1\23\1\40\1\34\1\36\1\41\4\1\1\51\1\60\1\52"
            + "\42\0\1\21\uff5f\0";

    /* En particular, la variable ZZ_CMAP_PACKED
  es una cadena que representa una tabla de mapeo de caracteres comprimida.
Esta tabla es utilizada por el analizador léxico para convertir secuencias de caracteres en tokens de salida. 
  Cada entrada de la tabla representa un rango de caracteres y su correspondiente valor de token. En este caso,
  la tabla ha sido comprimida para ahorrar espacio.
La tabla se genera a partir de las definiciones de tokens y de los patrones de expresiones regulares definidos
  en el archivo de especificación de JFlex. El proceso de generación de la tabla es parte del proceso de compilación del analizador léxico.
En resumen, este código es parte de la implementación de un analizador léxico generado por JFlex y 
  representa una tabla de mapeo de caracteres comprimida utilizada para convertir secuencias de caracteres en tokens de salida.
     */
    /**
     * Translates characters to character classes
     */
    private static final char[] ZZ_CMAP = zzUnpackCMap(ZZ_CMAP_PACKED);

    /**
     * Translates DFA states to action switch labels.
     */
    private static final int[] ZZ_ACTION = zzUnpackAction();

    private static final String ZZ_ACTION_PACKED_0
            = "\1\0\1\1\1\2\1\3\1\4\1\5\1\2\1\6"
            + "\1\1\1\7\1\1\1\2\3\7\1\10\1\11\10\2"
            + "\1\12\1\13\1\14\1\15\1\16\1\17\1\20\1\21"
            + "\1\22\1\23\1\24\1\25\1\26\1\27\2\1\1\2"
            + "\1\30\1\0\1\4\1\0\1\2\1\31\1\0\1\32"
            + "\3\0\1\2\1\33\2\0\6\2\1\0\4\2\1\34"
            + "\1\35\1\2\1\36\1\37\1\40\1\41\1\42\1\43"
            + "\1\0\1\2\2\0\1\4\1\44\1\32\1\45\1\0"
            + "\1\2\2\0\1\46\3\2\1\47\1\50\3\2\1\51"
            + "\5\2\1\0\1\2\1\0\1\2\1\0\1\2\2\0"
            + "\1\46\2\2\1\52\1\53\3\2\1\51\2\2\1\54"
            + "\1\55\1\2\1\0\2\2\1\33\1\0\1\46\1\0"
            + "\5\2\1\0\1\51\1\0\1\56\5\2\1\0\1\46"
            + "\1\0\5\2\1\0\1\51\1\0\4\2\1\0\5\2"
            + "\1\0\1\57\1\2\1\60\1\61\1\46\1\62\2\2"
            + "\1\63\1\2\1\51\4\2\1\64\1\2\1\65\1\66"
            + "\2\2\1\67";

    /*Este código representa la tabla de acciones comprimida que utiliza JFlex para generar analizadores léxicos. Esta tabla se utiliza para especificar 
  las acciones que se deben realizar cuando se encuentra un token en el código fuente.
La tabla está comprimida para reducir su tamaño, lo que permite que el analizador léxico generado sea más rápido y tenga un menor consumo de memoria.
Cada número en la tabla se refiere a una acción que debe ejecutarse. Por ejemplo, el número 1 puede indicar que se debe devolver un 
  token específico, mientras que el número 2 puede indicar que se debe ignorar el token actual.
La tabla de acciones se divide en varias secciones, cada una de las cuales se refiere a una regla o expresión
  regular específica en el archivo de entrada de JFlex. En general, la tabla de acciones se utiliza junto con la tabla de transiciones para construir un autómata finito determinista que reconoce los tokens en el código fuente.*/
    private static int[] zzUnpackAction() {
        int[] result = new int[191];
        int offset = 0;
        offset = zzUnpackAction(ZZ_ACTION_PACKED_0, offset, result);
        return result;
    }

    /*La cadena de caracteres con los enteros empacados se llama ZZ_ACTION_PACKED_0. La función zzUnpackAction() es la encargada de desempaquetar la
  cadena de caracteres y almacenar los valores en un arreglo de enteros llamado result. La función zzUnpackAction() recibe como parámetros la cadena empacada,
  un offset (un desplazamiento dentro de la cadena empacada para comenzar a leer), y un arreglo de enteros en el que se almacenarán los valores desempacados.*/
    private static int zzUnpackAction(String packed, int offset, int[] result) {
        int i = 0;
        /* index in packed string  */
        int j = offset;
        /* index in unpacked array */
        int l = packed.length();
        while (i < l) {
            int count = packed.charAt(i++);
            int value = packed.charAt(i++);
            do {
                result[j++] = value;
            } while (--count > 0);
        }
        return j;
    }
    /*La función zzUnpackAction() utiliza un ciclo while para recorrer la cadena empacada. En cada iteración del ciclo, se lee un par de caracteres de
  la cadena empacada. El primer caracter indica cuántos valores enteros están codificados en el siguiente caracter. El segundo caracter es el valor
  entero a decodificar. Se utiliza un segundo ciclo do-while para repetir la escritura del valor desempacado en el arreglo result tantas veces como 
  indique el primer caracter del par leído.*/

    /**
     * Translates a state to a row index in the transition table
     */
    private static final int[] ZZ_ROWMAP = zzUnpackRowMap();

    private static final String ZZ_ROWMAP_PACKED_0
            = "\0\0\0\62\0\144\0\226\0\310\0\372\0\u012c\0\u015e"
            + "\0\u0190\0\62\0\u01c2\0\u01f4\0\u0226\0\u0258\0\u028a\0\u02bc"
            + "\0\62\0\u02ee\0\u0320\0\u0352\0\u0384\0\u03b6\0\u03e8\0\u041a"
            + "\0\u044c\0\62\0\62\0\62\0\62\0\62\0\62\0\62"
            + "\0\62\0\62\0\u047e\0\62\0\u04b0\0\u04e2\0\u0514\0\u0546"
            + "\0\u0578\0\u05aa\0\62\0\372\0\u05dc\0\u060e\0\u0640\0\62"
            + "\0\u0190\0\u0672\0\u06a4\0\u06d6\0\u0708\0\u073a\0\u076c\0\u079e"
            + "\0\u07d0\0\u0802\0\u0834\0\u0866\0\u0898\0\u08ca\0\u08fc\0\u092e"
            + "\0\u0960\0\u0992\0\u09c4\0\u09f6\0\u05aa\0\u05aa\0\u0a28\0\62"
            + "\0\62\0\62\0\62\0\62\0\62\0\u0a5a\0\u0a8c\0\u0abe"
            + "\0\u0af0\0\u0af0\0\u0b22\0\u06a4\0\u0b54\0\u0b86\0\u0bb8\0\u0bea"
            + "\0\u0c1c\0\u0c4e\0\u0c80\0\u0cb2\0\u0ce4\0\u05aa\0\u05aa\0\u0d16"
            + "\0\u0d48\0\u0d7a\0\u0dac\0\u0dde\0\u0e10\0\u0e42\0\u0e74\0\u0ea6"
            + "\0\u0ed8\0\u0f0a\0\u0f3c\0\u0f6e\0\u01c2\0\u0fa0\0\u0fd2\0\u1004"
            + "\0\u1036\0\u1068\0\u109a\0\u05aa\0\u05aa\0\u10cc\0\u10fe\0\u1130"
            + "\0\u1162\0\u1194\0\u11c6\0\u05aa\0\u05aa\0\u11f8\0\u122a\0\u125c"
            + "\0\u128e\0\62\0\u12c0\0\u12f2\0\u1324\0\u1356\0\u1388\0\u13ba"
            + "\0\u13ec\0\u141e\0\u1450\0\u1482\0\u14b4\0\u05aa\0\u14e6\0\u1518"
            + "\0\u154a\0\u157c\0\u15ae\0\u15e0\0\u1612\0\u1644\0\u1676\0\u16a8"
            + "\0\u16da\0\u170c\0\u173e\0\u1770\0\u17a2\0\u17d4\0\u1806\0\u1838"
            + "\0\u186a\0\u189c\0\u18ce\0\u1900\0\u1932\0\u1964\0\u1996\0\u19c8"
            + "\0\u19fa\0\u05aa\0\u1a2c\0\u05aa\0\u05aa\0\u1a5e\0\u05aa\0\u1a90"
            + "\0\u1ac2\0\u05aa\0\u1af4\0\u1b26\0\u1b58\0\u1b8a\0\u1bbc\0\u1bee"
            + "\0\u05aa\0\u1c20\0\u05aa\0\u05aa\0\u1c52\0\u1c84\0\u05aa";

    /*
En esta tabla se almacenan índices que indican a qué fila del archivo de entrada corresponde cada token que se analiza.
  Estos índices son números enteros que se encuentran empaquetados en la cadena de caracteres entre comillas dobles.
Por ejemplo, el valor "\0\0\0\63" indica que el primer token corresponde a la fila 0, el segundo token a la fila 0, el
  tercer token a la fila 0, y el cuarto token a la fila 63. Cada dos caracteres de la cadena corresponden a un índice empaquetado en formato de 16 bits.
La función zzUnpackRowMap se utiliza para descomprimir la tabla empaquetada y generar el arreglo de enteros que contiene
  los índices de fila correspondientes a cada token.*/
    private static int[] zzUnpackRowMap() {
        int[] result = new int[191];
        int offset = 0;
        offset = zzUnpackRowMap(ZZ_ROWMAP_PACKED_0, offset, result);
        return result;
    }

    /*La función comienza creando un nuevo arreglo de enteros llamado result de tamaño 89. Luego, se inicializa una variable offset en cero, 
  que se utiliza para llevar un seguimiento de la posición actual en la cadena de bytes del mapa de filas comprimido.
Después, la función llama a otra función zzUnpackRowMap() con tres argumentos: el mapa de filas comprimido en formato String llamado 
  ZZ_ROWMAP_PACKED_0, el valor actual de offset y el arreglo result. Esta función desempaqueta el mapa
  de filas comprimido en el arreglo result, comenzando desde la posición actual offset y devuelve la nueva posición de offset.
Por último, la función devuelve el arreglo result, que ahora contiene el mapa de filas desempaquetado.

     */
    private static int zzUnpackRowMap(String packed, int offset, int[] result) {
        int i = 0;
        /* index in packed string  */
        int j = offset;
        /* index in unpacked array */
        int l = packed.length();
        while (i < l) {
            int high = packed.charAt(i++) << 16;
            result[j++] = high | packed.charAt(i++);
        }
        return j;
    }

    /*Este método se encarga de descomprimir un arreglo de enteros a partir de una cadena de caracteres que representa una versión 
  comprimida del arreglo. La cadena de caracteres está almacenada en la variable packed, y el arreglo resultante se almacenará en la variable result.
El método utiliza un bucle while para recorrer la cadena de caracteres packed. En cada iteración, se lee un número de 2 bytes 
  (16 bits) de la cadena de caracteres. El primer byte se multiplica por 2^16 y se convierte en un número entero de 32 bits. El 
  segundo byte se convierte en un número entero de 32 bits y se le suma el valor del primer byte multiplicado por 2^16. El resultado 
  final es un número entero de 32 bits que se almacena en la posición j del arreglo result. Después de cada iteración, el índice j se incrementa en 1 y el índice i se incrementa en 2.
El valor de retorno de este método es el índice j al final de la última iteración. Esto se utiliza para permitir la concatenación de
  varias versiones comprimidas de arreglos en una sola cadena de caracteres, y descomprimirlas secuencialmente.

     */
    /**
     * The transition table of the DFA
     */
    private static final int[] ZZ_TRANS = zzUnpackTrans();

    private static final String ZZ_TRANS_PACKED_0
            = "\1\2\1\3\1\4\1\5\1\6\1\7\1\10\1\11"
            + "\1\2\1\12\1\13\1\14\1\15\1\16\1\17\1\20"
            + "\1\21\1\2\1\22\5\3\1\23\1\24\1\25\2\3"
            + "\1\26\1\3\1\27\1\30\1\31\1\32\1\33\1\34"
            + "\1\35\1\36\1\37\1\40\1\41\1\42\1\43\1\44"
            + "\1\45\1\46\1\47\1\50\1\51\63\0\1\52\3\0"
            + "\1\52\5\0\1\52\6\0\20\52\22\0\1\53\1\5"
            + "\1\54\60\0\1\5\1\55\1\56\57\0\1\55\57\0"
            + "\1\52\3\0\1\52\5\0\1\52\6\0\11\52\1\57"
            + "\6\52\26\0\1\60\53\0\7\61\1\62\1\63\51\61"
            + "\10\64\1\65\1\64\1\0\47\64\1\0\1\52\3\0"
            + "\1\52\5\0\1\52\6\0\2\52\1\66\15\52\34\0"
            + "\1\15\62\0\1\16\62\0\1\17\62\0\1\67\1\70"
            + "\42\0\1\52\2\0\1\71\1\52\5\0\1\52\6\0"
            + "\1\52\1\72\2\52\1\73\13\52\21\0\1\52\3\0"
            + "\1\52\5\0\1\52\6\0\4\52\1\74\13\52\21\0"
            + "\1\52\3\0\1\75\5\0\1\52\6\0\20\52\21\0"
            + "\1\52\3\0\1\52\5\0\1\52\6\0\5\52\1\76"
            + "\3\52\1\77\6\52\21\0\1\52\2\0\1\100\1\52"
            + "\5\0\1\52\6\0\4\52\1\101\7\52\1\102\1\103"
            + "\2\52\21\0\1\52\3\0\1\104\5\0\1\52\6\0"
            + "\20\52\21\0\1\52\3\0\1\52\5\0\1\52\6\0"
            + "\10\52\1\105\1\106\6\52\21\0\1\52\3\0\1\107"
            + "\5\0\1\52\6\0\20\52\73\0\1\110\61\0\1\111"
            + "\61\0\1\112\61\0\1\113\66\0\1\114\62\0\1\115"
            + "\1\0\1\52\1\116\1\117\1\120\1\52\5\0\1\52"
            + "\6\0\20\52\23\0\1\55\1\0\1\56\56\0\1\121"
            + "\1\122\2\0\1\121\54\0\1\52\1\116\1\117\1\120"
            + "\1\52\5\0\1\52\6\0\12\52\1\123\5\52\27\0"
            + "\1\61\52\0\7\61\1\124\1\63\51\61\12\0\1\125"
            + "\57\0\1\126\52\0\1\52\1\116\1\117\1\120\1\52"
            + "\5\0\1\52\6\0\2\52\1\127\15\52\20\0\11\67"
            + "\1\0\50\67\20\130\1\131\41\130\1\0\1\132\3\0"
            + "\1\132\5\0\1\132\6\0\20\132\21\0\1\52\1\116"
            + "\1\117\1\120\1\52\5\0\1\52\6\0\2\52\1\133"
            + "\15\52\21\0\1\52\1\116\1\117\1\120\1\52\5\0"
            + "\1\52\6\0\1\52\1\134\14\52\1\135\1\52\21\0"
            + "\1\52\1\116\1\117\1\120\1\52\5\0\1\52\6\0"
            + "\1\52\1\136\5\52\1\137\10\52\21\0\1\52\1\116"
            + "\1\117\1\120\1\52\5\0\1\52\6\0\6\52\1\140"
            + "\11\52\21\0\1\52\1\116\1\117\1\120\1\52\5\0"
            + "\1\52\6\0\1\141\17\52\21\0\1\52\1\116\1\117"
            + "\1\120\1\52\5\0\1\52\6\0\6\52\1\142\11\52"
            + "\21\0\1\143\3\0\1\143\5\0\1\143\6\0\20\143"
            + "\21\0\1\52\1\116\1\117\1\120\1\52\5\0\1\52"
            + "\6\0\15\52\1\144\2\52\21\0\1\52\1\116\1\117"
            + "\1\120\1\52\5\0\1\52\6\0\11\52\1\145\6\52"
            + "\21\0\1\52\1\116\1\117\1\120\1\52\5\0\1\52"
            + "\6\0\2\52\1\146\15\52\21\0\1\52\1\116\1\117"
            + "\1\120\1\147\5\0\1\52\6\0\20\52\21\0\1\52"
            + "\1\116\1\117\1\120\1\52\5\0\1\52\6\0\1\52"
            + "\1\150\16\52\23\0\1\117\1\120\56\0\1\151\1\0"
            + "\1\117\1\152\1\153\5\0\1\151\6\0\20\151\23\0"
            + "\1\152\61\0\1\122\57\0\1\52\1\116\1\117\1\120"
            + "\1\52\5\0\1\52\6\0\2\52\1\154\15\52\32\0"
            + "\1\155\57\0\1\64\1\0\2\64\7\0\1\64\7\0"
            + "\3\64\25\0\1\52\1\116\1\117\1\120\1\52\5\0"
            + "\1\52\6\0\15\52\1\156\2\52\20\0\20\130\1\157"
            + "\41\130\20\0\1\131\1\160\41\0\1\161\3\0\1\161"
            + "\5\0\1\161\6\0\20\161\21\0\1\52\1\116\1\117"
            + "\1\120\1\52\5\0\1\52\6\0\3\52\1\162\2\52"
            + "\1\163\11\52\21\0\1\52\1\116\1\117\1\120\1\52"
            + "\5\0\1\52\6\0\4\52\1\164\13\52\21\0\1\52"
            + "\1\116\1\117\1\120\1\52\5\0\1\52\6\0\2\52"
            + "\1\165\15\52\21\0\1\52\1\116\1\117\1\120\1\52"
            + "\5\0\1\52\6\0\1\52\1\166\16\52\21\0\1\52"
            + "\1\116\1\117\1\120\1\52\5\0\1\52\6\0\1\52"
            + "\1\167\16\52\21\0\1\52\1\116\1\117\1\120\1\52"
            + "\5\0\1\52\6\0\1\52\1\170\16\52\21\0\1\171"
            + "\3\0\1\171\5\0\1\171\6\0\20\171\21\0\1\52"
            + "\1\116\1\117\1\120\1\52\5\0\1\52\6\0\16\52"
            + "\1\172\1\52\21\0\1\52\1\116\1\117\1\120\1\52"
            + "\5\0\1\52\6\0\6\52\1\173\11\52\21\0\1\52"
            + "\1\116\1\117\1\120\1\52\5\0\1\52\6\0\12\52"
            + "\1\174\5\52\21\0\1\52\1\116\1\117\1\120\1\52"
            + "\5\0\1\52\6\0\1\52\1\175\16\52\21\0\1\52"
            + "\1\116\1\117\1\120\1\52\5\0\1\52\6\0\7\52"
            + "\1\176\10\52\21\0\1\151\1\116\1\117\1\120\1\151"
            + "\5\0\1\151\6\0\20\151\21\0\1\151\1\0\1\152"
            + "\1\0\1\153\5\0\1\151\6\0\20\151\21\0\1\151"
            + "\1\116\1\117\1\120\1\151\1\177\4\0\1\151\6\0"
            + "\20\151\21\0\1\52\1\116\1\117\1\120\1\52\5\0"
            + "\1\52\6\0\11\52\1\200\6\52\21\0\1\52\1\116"
            + "\1\117\1\120\1\201\5\0\1\52\6\0\20\52\20\0"
            + "\17\130\1\202\1\157\41\130\17\0\1\202\43\0\1\161"
            + "\1\203\1\204\1\205\1\161\5\0\1\161\6\0\20\161"
            + "\21\0\1\52\1\116\1\117\1\120\1\52\5\0\1\52"
            + "\6\0\1\52\1\206\16\52\21\0\1\52\1\116\1\117"
            + "\1\120\1\207\5\0\1\52\6\0\20\52\21\0\1\52"
            + "\1\116\1\117\1\120\1\210\5\0\1\52\6\0\20\52"
            + "\21\0\1\52\1\116\1\117\1\120\1\52\5\0\1\52"
            + "\6\0\10\52\1\211\7\52\21\0\1\52\1\116\1\117"
            + "\1\120\1\212\5\0\1\52\6\0\20\52\21\0\1\171"
            + "\1\213\1\214\1\215\1\171\5\0\1\171\6\0\20\171"
            + "\21\0\1\52\1\116\1\117\1\120\1\52\5\0\1\52"
            + "\6\0\2\52\1\216\15\52\21\0\1\52\1\116\1\117"
            + "\1\120\1\52\5\0\1\52\6\0\10\52\1\217\7\52"
            + "\21\0\1\52\1\116\1\117\1\120\1\52\5\0\1\52"
            + "\6\0\4\52\1\220\13\52\23\0\1\221\57\0\1\52"
            + "\1\116\1\117\1\120\1\52\5\0\1\52\6\0\6\52"
            + "\1\222\11\52\21\0\1\52\1\116\1\117\1\120\1\52"
            + "\5\0\1\52\6\0\4\52\1\223\13\52\23\0\1\204"
            + "\1\205\56\0\1\224\1\0\1\204\1\225\1\226\5\0"
            + "\1\224\6\0\20\224\23\0\1\225\57\0\1\52\1\116"
            + "\1\117\1\120\1\52\5\0\1\52\6\0\4\52\1\227"
            + "\13\52\21\0\1\52\1\116\1\117\1\120\1\52\5\0"
            + "\1\52\6\0\7\52\1\230\10\52\21\0\1\52\1\116"
            + "\1\117\1\120\1\52\5\0\1\52\6\0\5\52\1\231"
            + "\12\52\21\0\1\52\1\116\1\117\1\120\1\52\5\0"
            + "\1\52\6\0\5\52\1\232\12\52\21\0\1\52\1\116"
            + "\1\117\1\120\1\52\5\0\1\52\6\0\5\52\1\233"
            + "\12\52\23\0\1\214\1\215\56\0\1\234\1\0\1\214"
            + "\1\235\1\236\5\0\1\234\6\0\20\234\23\0\1\235"
            + "\57\0\1\52\1\116\1\117\1\120\1\52\5\0\1\52"
            + "\6\0\2\52\1\237\15\52\21\0\1\52\1\116\1\117"
            + "\1\120\1\52\5\0\1\52\6\0\7\52\1\240\10\52"
            + "\21\0\1\151\1\0\1\221\1\0\1\151\5\0\1\151"
            + "\6\0\20\151\21\0\1\52\1\116\1\117\1\120\1\241"
            + "\5\0\1\52\6\0\20\52\21\0\1\52\1\116\1\117"
            + "\1\120\1\52\5\0\1\52\6\0\11\52\1\242\6\52"
            + "\21\0\1\224\1\203\1\204\1\205\1\224\5\0\1\224"
            + "\6\0\20\224\21\0\1\224\1\0\1\225\1\0\1\226"
            + "\5\0\1\224\6\0\20\224\21\0\1\224\1\203\1\204"
            + "\1\205\1\224\1\243\4\0\1\224\6\0\20\224\21\0"
            + "\1\52\1\116\1\117\1\120\1\52\5\0\1\52\6\0"
            + "\5\52\1\244\12\52\21\0\1\52\1\116\1\117\1\120"
            + "\1\52\5\0\1\52\6\0\10\52\1\245\7\52\21\0"
            + "\1\52\1\116\1\117\1\120\1\246\5\0\1\52\6\0"
            + "\20\52\21\0\1\52\1\116\1\117\1\120\1\52\5\0"
            + "\1\52\6\0\10\52\1\247\7\52\21\0\1\52\1\116"
            + "\1\117\1\120\1\250\5\0\1\52\6\0\20\52\21\0"
            + "\1\234\1\213\1\214\1\215\1\234\5\0\1\234\6\0"
            + "\20\234\21\0\1\234\1\0\1\235\1\0\1\236\5\0"
            + "\1\234\6\0\20\234\21\0\1\234\1\213\1\214\1\215"
            + "\1\234\1\251\4\0\1\234\6\0\20\234\21\0\1\52"
            + "\1\116\1\117\1\120\1\52\5\0\1\52\6\0\11\52"
            + "\1\252\6\52\21\0\1\52\1\116\1\117\1\120\1\253"
            + "\5\0\1\52\6\0\20\52\21\0\1\52\1\116\1\117"
            + "\1\120\1\52\5\0\1\52\6\0\16\52\1\254\1\52"
            + "\21\0\1\52\1\116\1\117\1\120\1\52\5\0\1\52"
            + "\6\0\2\52\1\255\15\52\23\0\1\256\57\0\1\52"
            + "\1\116\1\117\1\120\1\52\5\0\1\52\6\0\4\52"
            + "\1\257\13\52\21\0\1\52\1\116\1\117\1\120\1\52"
            + "\5\0\1\52\6\0\5\52\1\260\12\52\21\0\1\52"
            + "\1\116\1\117\1\120\1\52\5\0\1\52\6\0\11\52"
            + "\1\261\6\52\21\0\1\52\1\116\1\117\1\120\1\52"
            + "\5\0\1\52\6\0\1\52\1\262\16\52\21\0\1\52"
            + "\1\116\1\117\1\120\1\52\5\0\1\52\6\0\11\52"
            + "\1\263\6\52\23\0\1\264\57\0\1\52\1\116\1\117"
            + "\1\120\1\52\5\0\1\52\6\0\1\52\1\265\16\52"
            + "\21\0\1\224\1\0\1\256\1\0\1\224\5\0\1\224"
            + "\6\0\20\224\21\0\1\52\1\116\1\117\1\120\1\52"
            + "\5\0\1\52\6\0\10\52\1\266\7\52\21\0\1\52"
            + "\1\116\1\117\1\120\1\52\5\0\1\52\6\0\12\52"
            + "\1\267\5\52\21\0\1\52\1\116\1\117\1\120\1\52"
            + "\5\0\1\52\6\0\12\52\1\270\5\52\21\0\1\234"
            + "\1\0\1\264\1\0\1\234\5\0\1\234\6\0\20\234"
            + "\21\0\1\52\1\116\1\117\1\120\1\52\5\0\1\52"
            + "\6\0\2\52\1\271\15\52\21\0\1\52\1\116\1\117"
            + "\1\120\1\272\5\0\1\52\6\0\20\52\21\0\1\52"
            + "\1\116\1\117\1\120\1\52\5\0\1\52\6\0\2\52"
            + "\1\273\15\52\21\0\1\52\1\116\1\117\1\120\1\52"
            + "\5\0\1\52\6\0\2\52\1\274\15\52\21\0\1\52"
            + "\1\116\1\117\1\120\1\52\5\0\1\52\6\0\11\52"
            + "\1\275\6\52\21\0\1\52\1\116\1\117\1\120\1\52"
            + "\5\0\1\52\6\0\12\52\1\276\5\52\21\0\1\52"
            + "\1\116\1\117\1\120\1\52\5\0\1\52\6\0\2\52"
            + "\1\277\15\52\20\0";

    /*El código que presentas es un conjunto de cadenas de caracteres que representan una tabla de transiciones en un autómata 
  finito no determinístico (AFN) generado por la herramienta JFlex. En particular, la cadena ZZ_TRANS_PACKED_0 representa la 
  tabla de transiciones para el estado 0 del AFN generado.
Este código se genera automáticamente por JFlex a partir de la especificación de un analizador léxico en formato de archivo
  .jflex. La tabla de transiciones representa cómo el analizador léxico debe cambiar de estado a medida que lee caracteres de 
  entrada. Cada entrada en la tabla es un número que representa el siguiente estado al que el analizador debe cambiar, y las
  transiciones se organizan en filas y columnas correspondientes a los estados y caracteres de entrada, respectivamente.
En general, no es necesario entender ni modificar este código manualmente, ya que JFlex lo genera automáticamente en el proceso
  de compilación del analizador léxico.

     */
    private static int[] zzUnpackTrans() {
        int[] result = new int[7350];
        int offset = 0;
        offset = zzUnpackTrans(ZZ_TRANS_PACKED_0, offset, result);
        return result;
    }

    /*Este código generado por JFlex crea una tabla de transiciones para el análisis léxico generado por JFlex. La tabla de
  transiciones se utiliza para determinar el siguiente estado del analizador léxico basado en el estado actual y el carácter 
  de entrada. La tabla de transiciones se almacena como un arreglo de enteros comprimido para ahorrar espacio en memoria.
El método zzUnpackTrans() descomprime la tabla de transiciones almacenada en ZZ_TRANS_PACKED_0 y la guarda en el arreglo 
  result. El método toma como entrada una cadena de caracteres comprimida, un offset inicial y un arreglo de enteros. La 
  cadena de caracteres comprimida se descompone en pares de números, donde el primer número indica cuántas veces se debe 
  repetir el segundo número. Este proceso de descompresión se lleva a cabo mediante un bucle while.
El método zzUnpackTrans() se llama dentro del método zzUnpackTrans(). En este caso, el método se llama con la cadena de 
  caracteres comprimida ZZ_TRANS_PACKED_0, un offset inicial de cero y el arreglo result. El offset se utiliza para indicar 
  la posición en la cual se deben guardar los números descomprimidos en el arreglo result. El método devuelve la posición 
  final en la que se guardaron los números en el arreglo result. Finalmente, el arreglo result completo se devuelve al llamador del método zzUnpackTrans().
     */
    private static int zzUnpackTrans(String packed, int offset, int[] result) {
        int i = 0;
        /* index in packed string  */
        int j = offset;
        /* index in unpacked array */
        int l = packed.length();
        while (i < l) {
            int count = packed.charAt(i++);
            int value = packed.charAt(i++);
            value--;
            do {
                result[j++] = value;
            } while (--count > 0);
        }
        return j;
    }

    /*Este código es una función auxiliar utilizada por JFlex para desempaquetar una tabla de transición de estados. 
  Toma tres parámetros: una cadena de caracteres empaquetada que contiene la información de la tabla, un valor entero 
  que indica el índice donde comenzar a desempaquetar y un arreglo de enteros donde se almacenan los valores desempaquetados.

La función comienza inicializando tres variables: i, j y l. i es el índice actual en la cadena empaquetada, j es 
  el índice actual en el arreglo desempaquetado y l es la longitud de la cadena empaquetada.
Luego, se entra en un bucle while que se ejecutará mientras i sea menor que l. Dentro del bucle, se extrae un número 
  count de la cadena empaquetada, que indica cuántos elementos del mismo valor deben ser agregados al arreglo desempaquetado
  . Luego se extrae un número value que indica el valor que se debe agregar, se resta uno a value 
  y se utiliza un bucle do-while para agregar count copias de value al arreglo desempaquetado.
Finalmente, la función devuelve el índice actual en el arreglo desempaquetado. Este valor se utilizará para indicar el 
  punto de partida para desempaquetar la siguiente parte de la tabla de transición.*/

 /* error codes */
    private static final int ZZ_UNKNOWN_ERROR = 0;
    private static final int ZZ_NO_MATCH = 1;
    private static final int ZZ_PUSHBACK_2BIG = 2;

    /* error messages for the codes above */
    private static final String ZZ_ERROR_MSG[] = {
        "Unkown internal scanner error",
        "Error: could not match input",
        "Error: pushback value was too large"
    };

    /**
     * ZZ_ATTRIBUTE[aState] contains the attributes of state <code>aState</code>
     */
    private static final int[] ZZ_ATTRIBUTE = zzUnpackAttribute();

    private static final String ZZ_ATTRIBUTE_PACKED_0
            = "\1\0\1\11\7\1\1\11\6\1\1\11\10\1\11\11"
            + "\1\1\1\11\6\1\1\11\1\0\1\1\1\0\1\1"
            + "\1\11\1\0\1\1\3\0\2\1\2\0\6\1\1\0"
            + "\7\1\6\11\1\0\1\1\2\0\4\1\1\0\1\1"
            + "\2\0\17\1\1\0\1\1\1\0\1\1\1\0\1\1"
            + "\2\0\16\1\1\0\2\1\1\11\1\0\1\1\1\0"
            + "\5\1\1\0\1\1\1\0\6\1\1\0\1\1\1\0"
            + "\5\1\1\0\1\1\1\0\4\1\1\0\5\1\1\0"
            + "\26\1";

    /*El código generado por JFlex se refiere a una cadena de caracteres que contiene información sobre atributos para ser 
    usados en el análisis léxico. En particular, esta cadena parece ser parte de la definición de un analizador léxico que 
    reconoce tokens en un lenguaje de programación.
La cadena se llama ZZ_ATTRIBUTE_PACKED_0 y es una secuencia de caracteres que se utiliza para generar código de análisis 
    léxico en JFlex. En la cadena, los números representan los índices de los atributos y las letras indican el 
    tipo de atributo que se espera (por ejemplo, s para una cadena, i para un entero).
En general, el código generado por JFlex se utiliza como parte de la implementación de un analizador léxico 
    para reconocer tokens en un lenguaje de programación. Los detalles específicos de cómo se utiliza esta cadena de atributos
    dependerán del analizador léxico que se esté implementando.
*/
    
    private static int[] zzUnpackAttribute() {
        int[] result = new int[191];
        int offset = 0;
        offset = zzUnpackAttribute(ZZ_ATTRIBUTE_PACKED_0, offset, result);
        return result;
    }
    
    /*Este código generado por JFlex se refiere a una función que desempaqueta una cadena de caracteres comprimida en
    una matriz de enteros. La cadena comprimida es una representación compacta de los valores de los atributos de los 
    tokens generados por el analizador léxico.
La función zzUnpackAttribute toma tres argumentos: la cadena de caracteres comprimida, un offset que indica dónde 
    comenzar a desempaquetar los valores, y una matriz de enteros que se utilizará para almacenar los valores desempaquetados.
El código comienza inicializando la matriz de enteros result con un tamaño de 89, y luego inicializa el desplazamiento
    offset a cero. Luego, llama a la función zzUnpackAttribute con los argumentos ZZ_ATTRIBUTE_PACKED_0, 
    offset y result, y actualiza el valor de offset con el valor devuelto por la función.
Finalmente, la función devuelve la matriz de enteros result, que ahora contiene los valores de los atributos desempaquetados.*/

    private static int zzUnpackAttribute(String packed, int offset, int[] result) {
        int i = 0;
        /* index in packed string  */
        int j = offset;
        /* index in unpacked array */
        int l = packed.length();
        while (i < l) {
            int count = packed.charAt(i++);
            int value = packed.charAt(i++);
            do {
                result[j++] = value;
            } while (--count > 0);
        }
        return j;
    }

    /*Este método es generado por JFlex para desempaquetar una cadena de caracteres que representa un conjunto de valores
    de atributos de tokens. La cadena está codificada de una manera específica para ahorrar espacio en
    memoria. El método toma la cadena de entrada "empaquetada", la desempaqueta y guarda los valores de atributo resultantes en un arreglo de enteros.
El método zzUnpackAttribute() toma tres argumentos: la cadena empaquetada de atributos, un desplazamiento inicial 
    en el arreglo de salida y el arreglo de salida en el cual se guardarán los valores de atributo desempaquetados.
Dentro del método, i es el índice en la cadena empacada, j es el índice en el arreglo de salida, y l es la longitud de la cadena empacada.
El ciclo while itera sobre la cadena empacada. En cada iteración, se obtiene un número de caracteres que representa 
    la cantidad de valores de atributo a desempaquetar (count) y luego se desempaqueta ese número de valores de atributo
    (value). Los valores desempaquetados se guardan en el arreglo de salida en el índice j y se incrementa j para el siguiente valor.
Finalmente, el método devuelve el índice j, que representa la posición en el arreglo de salida después de haber desempaquetado todos los valores de atributo.

*/
    
    /**
     * the input device  
     * objeto de la clase java.io.Reader que se utiliza para leer el código fuente que se está analizando.
     */
    private java.io.Reader zzReader;

    /**
     * the current state of the DFA
     * entero que representa el estado actual del DFA (autómata finito determinista) generado por JFlex.
     */
    private int zzState;

    /**
     * the current lexical state
     * entero que indica el estado léxico actual, es decir, la posición actual dentro del análisis del código fuente.
     */
    private int zzLexicalState = YYINITIAL;

    /**
     * this buffer contains the current text to be matched and is the source of
     * the yytext() string
     * arreglo de caracteres que contiene el texto actual a analizar y que es la fuente del string yytext().
     */
    private char zzBuffer[] = new char[ZZ_BUFFERSIZE];

    /**
     * the textposition at the last accepting state
     * entero que indica la posición en el buffer en la que se encuentra la última aceptación del análisis léxico.
     */
    private int zzMarkedPos;

    /**
     * the current text position in the buffer
     * entero que indica la posición actual en el buffer durante el análisis léxico.
     */
    private int zzCurrentPos;

    /**
     * startRead marks the beginning of the yytext() string in the buffer
     * entero que indica la posición en el buffer en la que comienza el string yytext().
     */
    private int zzStartRead;

    /**
     * endRead marks the last character in the buffer, that has been read from
     * input
     * entero que indica la posición en el buffer hasta la cual se han leído caracteres del archivo de entrada.
     */
    private int zzEndRead;

    /**
     * number of newlines encountered up to the start of the matched text
     * entero que indica el número de líneas de código que se han leído hasta el comienzo del string yytext().
     */
    private int yyline;

    /**
     * the number of characters up to the start of the matched text
     * entero que indica la posición del primer caracter del string yytext() en el archivo de entrada.
     */
    private int yychar;

    /**
     * the number of characters from the last newline up to the start of the
     * matched text
     * entero que indica la posición del primer caracter del string yytext() respecto al último salto de línea en el archivo de entrada.
     */
    private int yycolumn;

    /**
     * zzAtBOL == true <=> the scanner is currently at the beginning of a line
     * booleano que indica si el analizador léxico se encuentra actualmente al comienzo de una línea de código.
     */
    private boolean zzAtBOL = true;

    /**
     * zzAtEOF == true <=> the scanner is at the EOF
     *  booleano que indica si el analizador léxico ha alcanzado el final del archivo de entrada.
     */
    private boolean zzAtEOF;

    /**
     * denotes if the user-EOF-code has already been executed
     * booleano que indica si se ha ejecutado el código de final de archivo (EOF) proporcionado por el usuario.
     */
    private boolean zzEOFDone;

    /* user code: */
    public String lexeme;
    Analisis c = new Analisis();
    int estado = 0;
    int nu = 0;

    /**
     * Creates a new scanner There is also a java.io.InputStream version of this
     * constructor.
     *
     * @param in the java.io.Reader to read input from.
     */
    Lexer(java.io.Reader in) {
        this.zzReader = in;
    }

    /**
     * Creates a new scanner. There is also java.io.Reader version of this
     * constructor.
     *
     * @param in the java.io.Inputstream to read input from.
     */
    Lexer(java.io.InputStream in) {
        this(new java.io.InputStreamReader(in));
    }

    /**
     * Unpacks the compressed character translation table.
     *
     * @param packed the packed character translation table
     * @return the unpacked character translation table
     */
    private static char[] zzUnpackCMap(String packed) {
        char[] map = new char[0x10000];
        int i = 0;
        /* index in packed string  */
        int j = 0;
        /* index in unpacked array */
        while (i < 126) {
            int count = packed.charAt(i++);
            char value = packed.charAt(i++);
            do {
                map[j++] = value;
            } while (--count > 0);
        }
        return map;
    }

    /**
     * Refills the input buffer.
     *
     * @return      <code>false</code>, iff there was new input.
     *
     * @exception java.io.IOException if any I/O-Error occurs
     */
    private boolean zzRefill() throws java.io.IOException {

        /* first: make room (if you can) */
        if (zzStartRead > 0) {
            System.arraycopy(zzBuffer, zzStartRead,
                    zzBuffer, 0,
                    zzEndRead - zzStartRead);

            /* translate stored positions */
            zzEndRead -= zzStartRead;
            zzCurrentPos -= zzStartRead;
            zzMarkedPos -= zzStartRead;
            zzStartRead = 0;
        }

        /* is the buffer big enough? */
        if (zzCurrentPos >= zzBuffer.length) {
            /* if not: blow it up */
            char newBuffer[] = new char[zzCurrentPos * 2];
            System.arraycopy(zzBuffer, 0, newBuffer, 0, zzBuffer.length);
            zzBuffer = newBuffer;
        }

        /* finally: fill the buffer with new input */
        int numRead = zzReader.read(zzBuffer, zzEndRead,
                zzBuffer.length - zzEndRead);

        if (numRead > 0) {
            zzEndRead += numRead;
            return false;
        }
        // unlikely but not impossible: read 0 characters, but not at end of stream    
        if (numRead == 0) {
            int c = zzReader.read();
            if (c == -1) {
                return true;
            } else {
                zzBuffer[zzEndRead++] = (char) c;
                return false;
            }
        }

        // numRead < 0
        return true;
    }
    
    /*
    Este código generado por Jflex es una implementación del método zzRefill() que se utiliza para 
    rellenar el buffer de entrada con nuevos caracteres. En resumen, el método funciona de la siguiente manera:
Primero, se verifica si hay espacio en el buffer para reubicar los caracteres leídos anteriormente.
    Si es así, se copian los caracteres restantes al principio del buffer y se ajustan las posiciones marcadas.
Luego, se verifica si el buffer tiene suficiente espacio para acomodar los nuevos caracteres. Si no,
    se crea un nuevo buffer con el doble de capacidad y se copian los caracteres antiguos en el nuevo buffer.
Finalmente, se lee el nuevo input y se llena el buffer con los caracteres leídos. Si se leyó algún caracter,
    se devuelve "false", lo que indica que el proceso de relleno fue exitoso y hay más caracteres disponibles
    en el buffer. Si no se leyó ningún caracter, se verifica si se llegó al final del archivo y se devuelve "true" si se alcanzó el final.
En general, el método es responsable de mantener el buffer lleno con nuevos caracteres a medida que se consumen
    los caracteres antiguos, y maneja de manera eficiente las situaciones en las que el buffer necesita ser reubicado o redimensionado.
    */

    /**
     * Closes the input stream.
     */
    public final void yyclose() throws java.io.IOException {
        zzAtEOF = true;
        /* indicate end of file */
        zzEndRead = zzStartRead;
        /* invalidate buffer    */

        if (zzReader != null) {
            zzReader.close();
        }
    }
    
    /*
    Este método es generado por JFlex y se encarga de cerrar el scanner. Cuando se llama a este método,
    se indica que se ha llegado al final del archivo y se invalida el contenido del buffer, lo que significa
    que ya no se puede leer más. Si se está utilizando un objeto java.io.Reader para leer el archivo, se llama 
    a su método close() para cerrar el archivo y liberar los recursos utilizados.
*/

    /**
     * Resets the scanner to read from a new input stream. Does not close the
     * old reader.
     *
     * All internal variables are reset, the old input stream
     * <b>cannot</b> be reused (internal buffer is discarded and lost). Lexical
     * state is set to <tt>ZZ_INITIAL</tt>.
     *
     * @param reader the new input stream
     */
    public final void yyreset(java.io.Reader reader) {
        zzReader = reader;
        zzAtBOL = true;
        zzAtEOF = false;
        zzEOFDone = false;
        zzEndRead = zzStartRead = 0;
        zzCurrentPos = zzMarkedPos = 0;
        yyline = yychar = yycolumn = 0;
        zzLexicalState = YYINITIAL;
    }
    
    /*El código generado por JFlex muestra el método yyreset() que se utiliza para restablecer el analizador léxico a su estado inicial. Toma un objeto Reader que se utilizará para leer la entrada y restablece todas las variables utilizadas por el analizador léxico a sus valores predeterminados.
El método yyreset() realiza las siguientes acciones:
Asigna el objeto Reader al atributo zzReader.
Establece zzAtBOL a true para indicar que estamos al principio de una línea.
Establece zzAtEOF a false para indicar que no hemos alcanzado el final del archivo.
Establece zzEOFDone a false para indicar que aún no se ha ejecutado el código del usuario para el final del archivo.
Establece zzEndRead y zzStartRead en 0 para invalidar el búfer.
Establece zzCurrentPos y zzMarkedPos en 0 para reiniciar la posición del búfer.
Establece yyline, yychar y yycolumn en 0 para reiniciar las variables que se usan para hacer un seguimiento de la posición del analizador.
Establece zzLexicalState en YYINITIAL para restablecer el estado léxico del analizador.*/

    /**
     * Returns the current lexical state.
     */
    public final int yystate() {
        return zzLexicalState;
    }

    /**
     * Enters a new lexical state
     *
     * @param newState the new lexical state
     */
    public final void yybegin(int newState) {
        zzLexicalState = newState;
    }

    /**
     * Returns the text matched by the current regular expression.
     */
    public final String yytext() {
        return new String(zzBuffer, zzStartRead, zzMarkedPos - zzStartRead);
    }
    
    /*Estos son tres métodos importantes generados por JFlex en el análisis léxico de un archivo de entrada:

yystate(): devuelve el estado actual del analizador léxico, es decir, el estado del autómata finito determinista (DFA) en el que se encuentra.
yybegin(int newState): cambia el estado actual del analizador léxico al estado newState.
yytext(): devuelve la cadena de texto correspondiente a la última expresión regular que se ha encontrado y
    que ha activado una transición a un nuevo estado del DFA.
En resumen, estos métodos son útiles para el programador que utilice JFlex para conocer el estado actual del analizador léxico, 
    cambiar de estado y obtener la cadena de texto correspondiente a la última expresión regular encontrada en el archivo de entrada.*/

    /**
     * Returns the character at position <tt>pos</tt> from the matched text.
     *
     * It is equivalent to yytext().charAt(pos), but faster
     *
     * @param pos the position of the character to fetch. A value from 0 to
     * yylength()-1.
     *
     * @return the character at position pos
     */
    public final char yycharat(int pos) {
        return zzBuffer[zzStartRead + pos];
    }

    /**
     * Returns the length of the matched text region.
     */
    public final int yylength() {
        return zzMarkedPos - zzStartRead;
    }

    /**
     * Reports an error that occured while scanning.
     *
     * In a wellformed scanner (no or only correct usage of yypushback(int) and
     * a match-all fallback rule) this method will only be called with things
     * that "Can't Possibly Happen". If this method is called, something is
     * seriously wrong (e.g. a JFlex bug producing a faulty scanner etc.).
     *
     * Usual syntax/scanner level error handling should be done in error
     * fallback rules.
     *
     * @param errorCode the code of the errormessage to display
     */
    private void zzScanError(int errorCode) {
        String message;
        try {
            message = ZZ_ERROR_MSG[errorCode];
        } catch (ArrayIndexOutOfBoundsException e) {
            message = ZZ_ERROR_MSG[ZZ_UNKNOWN_ERROR];
        }

        throw new Error(message);
    }

    /**
     * Pushes the specified amount of characters back into the input stream.
     *
     * They will be read again by then next call of the scanning method
     *
     * @param number the number of characters to be read again. This number must
     * not be greater than yylength()!
     */
    public void yypushback(int number) {
        if (number > yylength()) {
            zzScanError(ZZ_PUSHBACK_2BIG);
        }

        zzMarkedPos -= number;
    }
    
    /*Este código es parte de la implementación del analizador léxico generado por JFlex
    y se refiere a la operación de empujar de vuelta (pushback) caracteres en el flujo de entrada.
El método yypushback(int number) permite retroceder un número determinado de caracteres 
    en el flujo de entrada. Esto se logra moviendo la posición de marcado zzMarkedPos 
    hacia atrás por el número de caracteres especificado por number.
Antes de retroceder, el método comprueba si el número de caracteres a retroceder es 
    mayor que el número de caracteres actualmente disponibles para retroceder (yylength()). Si es así, se lanza una excepción ZZ_PUSHBACK_2BIG.
Es importante tener en cuenta que este método solo puede utilizarse para retroceder en 
    el flujo de entrada inmediatamente después de la llamada a yytext(). Si se llama 
    a otros métodos de análisis léxico después de yytext(), no se puede hacer uso del método yypushback().*/

    /**
     * Resumes scanning until the next regular expression is matched, the end of
     * input is encountered or an I/O-Error occurs.
     *
     * @return the next token
     * @exception java.io.IOException if any I/O-Error occurs
     */
    public Tokens yylex() throws java.io.IOException {
        int zzInput;
        int zzAction;

        // cached fields:
        int zzCurrentPosL;
        int zzMarkedPosL;
        int zzEndReadL = zzEndRead;
        char[] zzBufferL = zzBuffer;
        char[] zzCMapL = ZZ_CMAP;

        int[] zzTransL = ZZ_TRANS;
        int[] zzRowMapL = ZZ_ROWMAP;
        int[] zzAttrL = ZZ_ATTRIBUTE;

        while (true) {
            zzMarkedPosL = zzMarkedPos;

            boolean zzR = false;
            for (zzCurrentPosL = zzStartRead; zzCurrentPosL < zzMarkedPosL;
                    zzCurrentPosL++) {
                switch (zzBufferL[zzCurrentPosL]) {
                    case '\u000B':
                    case '\u000C':
                    case '\u0085':
                    case '\u2028':
                    case '\u2029':
                        yyline++;
                        yycolumn = 0;
                        zzR = false;
                        break;
                    case '\r':
                        yyline++;
                        yycolumn = 0;
                        zzR = true;
                        break;
                    case '\n':
                        if (zzR) {
                            zzR = false;
                        } else {
                            yyline++;
                            yycolumn = 0;
                        }
                        break;
                    default:
                        zzR = false;
                        yycolumn++;
                }
            }

            if (zzR) {
                // peek one character ahead if it is \n (if we have counted one line too much)
                boolean zzPeek;
                if (zzMarkedPosL < zzEndReadL) {
                    zzPeek = zzBufferL[zzMarkedPosL] == '\n';
                } else if (zzAtEOF) {
                    zzPeek = false;
                } else {
                    boolean eof = zzRefill();
                    zzEndReadL = zzEndRead;
                    zzMarkedPosL = zzMarkedPos;
                    zzBufferL = zzBuffer;
                    if (eof) {
                        zzPeek = false;
                    } else {
                        zzPeek = zzBufferL[zzMarkedPosL] == '\n';
                    }
                }
                if (zzPeek) {
                    yyline--;
                }
            }
            zzAction = -1;

            zzCurrentPosL = zzCurrentPos = zzStartRead = zzMarkedPosL;

            zzState = ZZ_LEXSTATE[zzLexicalState];

            zzForAction:
            {
                while (true) {

                    if (zzCurrentPosL < zzEndReadL) {
                        zzInput = zzBufferL[zzCurrentPosL++];
                    } else if (zzAtEOF) {
                        zzInput = YYEOF;
                        break zzForAction;
                    } else {
                        // store back cached positions
                        zzCurrentPos = zzCurrentPosL;
                        zzMarkedPos = zzMarkedPosL;
                        boolean eof = zzRefill();
                        // get translated positions and possibly new buffer
                        zzCurrentPosL = zzCurrentPos;
                        zzMarkedPosL = zzMarkedPos;
                        zzBufferL = zzBuffer;
                        zzEndReadL = zzEndRead;
                        if (eof) {
                            zzInput = YYEOF;
                            break zzForAction;
                        } else {
                            zzInput = zzBufferL[zzCurrentPosL++];
                        }
                    }
                    int zzNext = zzTransL[zzRowMapL[zzState] + zzCMapL[zzInput]];
                    if (zzNext == -1) {
                        break zzForAction;
                    }
                    zzState = zzNext;

                    int zzAttributes = zzAttrL[zzState];
                    if ((zzAttributes & 1) == 1) {
                        zzAction = zzState;
                        zzMarkedPosL = zzCurrentPosL;
                        if ((zzAttributes & 8) == 8) {
                            break zzForAction;
                        }
                    }

                }
            }

            // store back cached position
            zzMarkedPos = zzMarkedPosL;

            switch (zzAction < 0 ? zzAction : ZZ_ACTION[zzAction]) {
                case 12: {
                    c.linea = yyline;
                    lexeme = yytext();
                    return dos_puntos;
                }
                case 56:
                    break;
                case 31: {
                    c.linea = yyline;
                    lexeme = yytext();
                    return menorigual;
                }
                case 57:
                    break;
                case 17: {
                    c.linea = yyline;
                    lexeme = yytext();
                    return llave_abre;
                }
                case 58:
                    break;
                case 37: {
                    c.linea = yyline;
                    lexeme = yytext();
                    return caracter;
                }
                case 59:
                    break;
                case 36: {
                    c.linea = yyline;
                    lexeme = yytext();
                    return ent;
                }
                case 60:
                    break;
                case 10: {
                    c.linea = yyline;
                    lexeme = yytext();
                    return punto_coma;
                }
                case 61:
                    break;
                case 5: {
                    c.linea = yyline;
                    lexeme = yytext();
                    return punto;
                }
                case 62:
                    break;
                case 43: {
                    c.linea = yyline;
                    lexeme = yytext();
                    return paso;
                }
                case 63:
                    break;
                case 53: {
                    c.linea = yyline;
                    lexeme = yytext();
                    return decremento;
                }
                case 64:
                    break;
                case 6: {
                    c.linea = yyline;
                    lexeme = yytext();
                    return mas;
                }
                case 65:
                    break;
                case 44: {
                    c.linea = yyline;
                    lexeme = yytext();
                    return flot;
                }
                case 66:
                    break;
                case 3: {
                    c.linea = yyline;
                    lexeme = yytext();
                    return menos;
                }
                case 67:
                    break;
                case 54: {
                    c.linea = yyline;
                    lexeme = yytext();
                    return incremento;
                }
                case 68:
                    break;
                case 24: {
                    c.linea = yyline;
                    lexeme = yytext();
                    return decre;
                }
                case 69:
                    break;
                case 20: {
                    c.linea = yyline;
                    lexeme = yytext();
                    return modulo;
                }
                case 70:
                    break;
                case 47: {
                    estado = 3;
                    c.linea = yyline;
                    lexeme = yytext();
                    return funcion;
                }
                case 71:
                    break;
                case 33: {
                    c.linea = yyline;
                    lexeme = yytext();
                    return diferente_de;
                }
                case 72:
                    break;
                case 51: {
                    c.linea = yyline;
                    lexeme = yytext();
                    return imprimir;
                }
                case 73:
                    break;
                case 13: {
                    c.linea = yyline;
                    lexeme = yytext();
                    return parentesis_abre;
                }
                case 74:
                    break;
                case 27: {
                    /* Ignore */
                }
                case 75:
                    break;
                case 19: {
                    c.linea = yyline;
                    lexeme = yytext();
                    return igual;
                }
                case 76:
                    break;
                case 25: {
                    c.linea = yyline;
                    lexeme = yytext();
                    return incre;
                }
                case 77:
                    break;
                case 39: {
                    c.linea = yyline;
                    lexeme = yytext();
                    return car;
                }
                case 78:
                    break;
                case 28: {
                    c.linea = yyline;
                    lexeme = yytext();
                    return si;
                }
                case 79:
                    break;
                case 55: {
                    estado = 2;
                    c.linea = yyline;
                    lexeme = yytext();
                    return procedimiento;
                }
                case 80:
                    break;
                case 41: {
                    c.linea = yyline;
                    lexeme = yytext();
                    return IDF;
                }
                case 81:
                    break;
                case 8: {
                    c.linea = yyline;
                    lexeme = yytext();
                    return division;
                }
                case 82:
                    break;
                case 16: {
                    c.linea = yyline;
                    lexeme = yytext();
                    return corchete_cierra;
                }
                case 83:
                    break;
                case 21: {
                    c.linea = yyline;
                    lexeme = yytext();
                    return menor_que;
                }
                case 84:
                    break;
                case 45: {
                    c.linea = yyline;
                    lexeme = yytext();
                    return leer;
                }
                case 85:
                    break;
                case 30: {
                    c.linea = yyline;
                    lexeme = yytext();
                    return comparacion;
                }
                case 86:
                    break;
                case 14: {
                    c.linea = yyline;
                    lexeme = yytext();
                    return parentesis_cierra;
                }
                case 87:
                    break;
                case 9: {
                    c.linea = yyline;
                    lexeme = yytext();
                    return multiplicacion;
                }
                case 88:
                    break;
                case 4: {
                    c.linea = yyline;
                    lexeme = yytext();
                    return Numero;
                }
                case 89:
                    break;
                case 22: {
                    c.linea = yyline;
                    lexeme = yytext();
                    return mayor_que;
                }
                case 90:
                    break;
                case 23: {
                    c.linea = yyline;
                    lexeme = yytext();
                    return negacion;
                }
                case 91:
                    break;
                case 35: {
                    c.linea = yyline;
                    lexeme = yytext();
                    return and;
                }
                case 92:
                    break;
                case 52: {
                    c.linea = yyline;
                    lexeme = yytext();
                    return verdadero;
                }
                case 93:
                    break;
                case 18: {
                    c.linea = yyline;
                    lexeme = yytext();
                    return llave_cierra;
                }
                case 94:
                    break;
                case 11: {
                    c.linea = yyline;
                    lexeme = yytext();
                    return coma;
                }
                case 95:
                    break;
                case 46: {
                    c.linea = yyline;
                    lexeme = yytext();
                    return falso;
                }
                case 96:
                    break;
                case 15: {
                    nu = 1;
                    c.linea = yyline;
                    lexeme = yytext();
                    return corchete_abre;
                }
                case 97:
                    break;
                case 50: {
                    estado = 1;
                    c.linea = yyline;
                    lexeme = yytext();
                    return programa;
                }
                case 98:
                    break;
                case 29: {
                    c.linea = yyline;
                    lexeme = yytext();
                    return sn;
                }
                case 99:
                    break;
                case 26: {
                    c.linea = yyline;
                    lexeme = yytext();
                    return cadena;
                }
                case 100:
                    break;
                case 42: {
                    c.linea = yyline;
                    lexeme = yytext();
                    return para;
                }
                case 101:
                    break;
                case 38: {
                    c.linea = yyline;
                    lexeme = yytext();
                    return IDK;
                }
                case 102:
                    break;
                case 48: {
                    c.linea = yyline;
                    lexeme = yytext();
                    return entonces;
                }
                case 103:
                    break;
                case 7: {
                    /*Ignore*/
                }
                case 104:
                    break;
                case 32: {
                    c.linea = yyline;
                    lexeme = yytext();
                    return mayorigual;
                }
                case 105:
                    break;
                case 34: {
                    c.linea = yyline;
                    lexeme = yytext();
                    return or;
                }
                case 106:
                    break;
                case 2: {
                    if (estado == 1) { // Si se encontró la palabra clave "Programa"
                        c.linea = yyline;
                        lexeme = yytext();
                        estado = 0;
                        return IDP;
                    } else if (estado == 2) {
                        c.linea = yyline;
                        lexeme = yytext();
                        estado = 0;
                        return IDK;
                    } else if (estado == 3) {
                        c.linea = yyline;
                        lexeme = yytext();
                        estado = 0;
                        return IDF;
                    } else { // Si no se ha encontrado "Programa"
                        c.linea = yyline;
                        lexeme = yytext();
                        return ID; // Token para identificador normal
                    }
                }
                case 107:
                    break;
                case 49: {
                    c.linea = yyline;
                    lexeme = yytext();
                    return booleano;
                }
                case 108:
                    break;
                case 40: {
                    c.linea = yyline;
                    lexeme = yytext();
                    return cad;
                }
                case 109:
                    break;
                case 1: {
                    c.linea = yyline;
                    lexeme = yytext();
                    return Error;
                }
                case 110:
                    break;
                default:
                    if (zzInput == YYEOF && zzStartRead == zzCurrentPos) {
                        zzAtEOF = true;
                        return null;
                    } else {
                        zzScanError(ZZ_NO_MATCH);
                    }
            }
        }
    }

}
